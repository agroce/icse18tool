\section{Introduction}

The universal mutator (\url{https://github.com/agroce/universalmutator}) is a tool for mutation testing \cite{PracProg,Mut2000}.  
Three principles:

\begin{enumerate}
\item Text can approximate most AST-aware mutants in practice.
\item Leverage TCE.
\item Gopinath et. al let a thousand mutants bloom.
\end{enumerate}

\begin{figure}
{\scriptsize
\begin{code}
DO\_NOT\_MUTATE ==> DO\_NOT\_MUTATE

\\+ ==> -
\\+ ==> *
\\+ ==> /
\\+ ==> \%

-([^>]) ==> +\\1
-([^>]) ==> *\\1
-([^>]) ==> /\\1
-([^>]) ==> \%\\1

([^/*])\*([^/*]) ==> \\1+\\2
([^/*])\*([^/*]) ==> \\1-\\2
([^/*])\*([^/*]) ==> \\1/\\2
([^/*])\*([^/*]) ==> \\1\%\\2

([^\*/])/([^\*/]) ==> \\1+\\2
([^\*/])/([^\*/]) ==> \\1-\\2
([^\*/])/([^\*/]) ==> \\1*\\2
([^\*/])/([^\*/]) ==> \\1\%\\2

\% ==> +
\% ==> -
\% ==> *
\% ==> /

!= ==> ==
!= ==> <=
!= ==> >=
!= ==> >
!= ==> <

== ==> !=
== ==> <=
== ==> >=
== ==> >
== ==> <

>= ==> ==
>= ==> !=
>= ==> <
>= ==> >

<= ==> ==
<= ==> !=
<= ==> <
<= ==> >

< ==> >
< ==> ==

([^-])> ==> \\1<
([^-])> ==> \\1==

-([^>]) ==> \\1

(\\D)(\\d+)(\\D) ==> \\g<1>0\\3
(\\D)(\\d+)(\\D) ==> \\g<1>1\\3
(\\D)(\\d+)(\\D) ==> \\g<1>-1\\3
(\\D)(\\d+)(\\D) ==> \\1\\2+1\\3
(\\D)(\\d+)(\\D) ==> \\1\\2-1\\3
\&\& ==> ||
\\|\\| ==> \&\&
! ==>

([^\&])\&([^\&]) ==> \\1|\\2
([^|])\\|([^|]) ==> \\1\&\\2

(^\\s*)(\\S+.*)\\n ==> \\1\\2\\n\\1break;\\n

".+" ==> ""
\end{code}
}
\caption{Universal mutation rules for all languages.}
\label{fig:universal}
\end{figure}

Figure \ref{fig:universal} shows the set of rules that are applied in
common to all languages.  Some of these rules are irrelevant to some
languages (for instance, Python does not use {\tt \&\&} as a logical
operator), but in such cases the present of the rule is harmless.  The
core mutations defined here include various operator replacements,
numeric and string constant replacements (introducing several
additions to the set used by Andrews \cite{mutant}, such as replacing
any string by the empty string), and the insertion of new {\tt break}
statements.  The universal rules also include an example of a
mechanism for annotating that a line should never be mutated.  This is
a feature not (to our knowledge) present in most tools, but can be
useful:  first, some lines may be known to related to untested code
(e.g., {\tt WARNING} messages that are never checked by tests);
second, in rare instances a statment may be dangerous to mutate, such
as a network or file system operation, but there is interest in
mutating other aspects of computation.

